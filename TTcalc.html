<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.16.0.css">
<link rel="stylesheet" href="bootstrap.min.css">
<style type="text/css"><style type="text/css">
		
		table input[type=text][readonly] {
			background: transparent;
			border: none;
		}
		table .hilite {
			background-color: #dff0d8 !important;
		}
		#nonidle input {
			width: 100px;
		}
		.wrapper {
			width: 1504px;
			margin: 0px auto;
		}
		body {
			margin: 15px;
		}
		.btn + .btn {
			margin-left: 10px;
		}
		.table > tbody > tr > td{
			padding: 0px;
			vertical-align: middle;
		}
		.panel-heading > * {
			vertical-align: middle;
		}
		.panel-heading button {
			border: none;
			background: none;
			padding: 0px 1px 0px 1px;
		}
		
		input[type=text] {
    width: 100px;
    margin: 0px;
		border:none;
}
</style>

<title>Tap Titans Heroes Calculator</title>
  <!--<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>-->
</head>
<body>
	<div class="mojemenu" style="float: left; width: 180px">
		<div class="menuItem">
			<a href="TTcalc.html">Tap Titans Calculator</a>
		</div>
	</div>
	<div class="wrapper">
		<div class="panel panel-danger">
			<div class="panel-heading">Read me!</div>
			<div class="panel-body">
				<p align="center">
				This calculator is based on <b>1.2.1</b> of the game. Be aware of difference between it and iOS version. <br><br> 
				<b>Instructions:</b> <br> 
				- fill levels and skills of your heroes and artifact. Calculator automaticly assume that you own the skill if the hero level is higher than the skill req. It doesnt if the hero level is same as skill level req. Be aware of that. <br> 
				- Tapping options can be found under Player tab. If you dont plan to tap, set number of clicks to 0. <br>
				- save panel is solely used for the calculator info. It saves time from filling all the required info, like artifact levels, every time you refresh the page. <br>
				- Update Tables button only updates informations in the 3 tables. <br>
				- Update Button on save panel calculates the best leveling sequence for the heroes, including skills (Goldwise). You have to manually fill the positions you completed for now. <br><br>
				- You can specify number of steps you want to calculate.
				BE AWARE OF THE DISPLAY BUGS. SOMETIMES NUMBERS MAY DIFFER FROM WHAT YOU SEE IN THE GAME.
				<!-- If the calculator asks you to upgrade hero to level when you can buy a skill, it usually means it also wants you to buy it. -->
				
				</p>
			</div>
		</div>
		<div style="width: 500px; display: inline-block;">
			<div class="panel panel-primary">
				<div class="panel-heading">Save panel</div>
				<div class="panel-body">
					<textarea id="savedata" style="width: 100%; height: 50px"></textarea>
					<div style="margin-top: 10px;">
						<button type="button" onclick="EfficiencyCalculations()" class="btn btn-default">Update</button>
						<button type="button" onclick="Load()" class="btn btn-primary" style="float: right;">Load</button>
						<button type="button" onclick="Save()" class="btn btn-default" style="float: right;">Save</button>
					</div>
				</div>
			</div>
		<!--<label><input type="checkbox" id="addsouls" checked="checked">Include souls gained after ascension</label>-->
			<div class="panel panel-success">
				<div class="panel-heading">Results: <input type="text" id="numberofpredictions" value="30">
				</div>
				<div id="output" class="panel-body"></div>
			</div>
		</div>
		<div role="tabpanel" style="width: 1000px; display: inline-block; vertical-align: top;">
			<ul class="nav nav-tabs" role="tablist">
				<li role="presentation" class="active"><a href="#heroes" aria-controls="heroes" role="tab" data-toggle="tab">Heroes</a></li>
				<li role="presentation"><a href="#player" aria-controls="player" role="tab" data-toggle="tab">Player</a></li>
				<li role="presentation"><a href="#artifacts" aria-controls="artifacts" role="tab" data-toggle="tab">Artifacts</a></li>
			</ul>
			<div class="tab-content">
				<div role="tabpanel" class="tab-pane active" id="heroes"><div> &nbsp </div>
					<table id="ancienttbl" class="table table-striped">
						<tbody><tr><th width="25%">Name</th><th width="20%">Skills</th><th width="15%">Upgrade Cost</th><th width="15%">DpS</th width="20%"><th>Next Level DpS Diff</th><th width="5%">Level</th></tr>
						</tbody>
					</table>
				</div>
				<div role="tabpanel" class="tab-pane" id="player"><div> &nbsp </div>
					<table id="playertbl" class="table table-striped">
						<tbody><tr><th width="25%">Name</th><th width="15%">Upgrade Cost</th><th width="15%">DpS</th width="20%"><th>Next Level DpS Diff</th><th width="5%">Level</th><th>Click per Second</th></tr>
						</tbody>
					</table>
					<div id="playerdata">
					</div>
				</div>
				<div role="tabpanel" class="tab-pane" id="artifacts"><div> &nbsp </div>
					<table id="artifacttable" class="table table-striped">
						<tbody>
						</tbody>
					</table>
				</div>
			</div>
			<button type="button" onclick="UpdateTables()" class="btn btn-default">Update Tables</button>
		</div>
	</div>
  
  
<script type="text/javascript" src="jquery-latest.min.js"></script>
<script type="text/javascript" src="bootstrap.min.js"></script>
<script src="common.js"></script>

<script language="javascript">/* Write JavaScript here */
//$(window).load(function start(){

for (var i = 0; i < 30; i++) {
  var key = heroList[i];
  var tr = HeroInfo[key].targetBox = $("<tr></tr>");
  tr.append($("<td></td>").append(HeroInfo[key].name).attr("id", key+"name"));
  HeroInfo[key].used1 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill1").attr("title", "ha");
  HeroInfo[key].used2 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill2").attr("title", "ha");
  HeroInfo[key].used3 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill3").attr("title", "ha");
  HeroInfo[key].used4 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill4").attr("title", "ha");
  HeroInfo[key].used5 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill5").attr("title", "ha");
  HeroInfo[key].used6 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill6").attr("title", "ha");
  HeroInfo[key].used7 = $("<input></input>").attr("type", "checkbox").attr("id", key+"skill7").attr("title", "ha");
  tr.append($("<td></td>").append(HeroInfo[key].used1).append(HeroInfo[key].used2).append(HeroInfo[key].used3).append(HeroInfo[key].used4).append(HeroInfo[key].used5).append(HeroInfo[key].used6).append(HeroInfo[key].used7));
  if (HeroInfo[key].nextUpgradeCost > 1000000)
  {
	tr.append($("<td></td>").append(HeroInfo[key].nextUpgradeCost.toExponential(2)).attr("id", key+"nextUpgradeCost"));
  }
  else
  {
	tr.append($("<td></td>").append(HeroInfo[key].nextUpgradeCost).attr("id", key+"nextUpgradeCost"));
  }
  tr.append($("<td></td>").append(HeroInfo[key].currentDPS).attr("id", key+"currentDPS"));
  tr.append($("<td></td>").append(HeroInfo[key].nextLevelDPSDiff).attr("id", key+"nextLevelDPSDiff"));
  tr.append($("<td></td>").append($("<input></input>").attr("type", "text").val(0).attr("id", key+"heroLevel")));
  tr.append("\n\n");
  $("#ancienttbl").append(tr);
}

{
	var tr2 = HeroInfo[heroList[30]].targetBox = $("<tr></tr>");
	tr2.append($("<td></td>").append(HeroInfo[heroList[30]].name).attr("id", "player0name"));
	tr2.append($("<td></td>").append(HeroInfo[heroList[30]].nextUpgradeCost).attr("id", "player0nextUpgradeCost"));
	tr2.append($("<td></td>").append(HeroInfo[heroList[30]].currentDPS).attr("id", "player0currentDPS"));
	tr2.append($("<td></td>").append(HeroInfo[heroList[30]].nextLevelDPSDiff).attr("id", "player0nextLevelDPSDiff"));
	tr2.append($("<td></td>").append($("<input></input>").attr("type", "text").val(1).attr("id", "player0heroLevel")));
	tr2.append($("<td></td>").append($("<input></input>").attr("type", "text").val(5).attr("id", "player0clicks")));
	tr2.append("\n\n");
	$("#playertbl").append(tr2);
}

function printHeroInfo(hero)
{
	//if (hero.currentDPS > 1000000) { $("#Hero"+(hero.heroID)+"currentDPS").html(hero.currentDPS.toExponential(3)); } else { $("#Hero"+hero.heroID+"currentDPS").html(Math.floor(hero.currentDPS)); }
	//if (hero.nextLevelDPSDiff > 1000000) { $("#Hero"+(hero.heroID)+"nextLevelDPSDiff").html("+ "+hero.nextLevelDPSDiff.toExponential(3)); } else { $("#Hero"+hero.heroID+"nextLevelDPSDiff").html("+ "+Math.floor(hero.nextLevelDPSDiff)); }
	//if (hero.nextUpgradeCost > 1000000) { $("#Hero"+(hero.heroID)+"nextUpgradeCost").html(hero.nextUpgradeCost.toExponential(3)); } else { $("#Hero"+hero.heroID+"nextUpgradeCost").html(Math.floor(hero.nextUpgradeCost)); }
	if (hero.currentDPS > 1000) { $("#Hero"+(hero.heroID)+"currentDPS").html(numberFormat(hero.currentDPS)); } else { $("#Hero"+hero.heroID+"currentDPS").html(Math.floor(hero.currentDPS)); }
	if (hero.nextLevelDPSDiff > 1000) { $("#Hero"+(hero.heroID)+"nextLevelDPSDiff").html("+ "+numberFormat(hero.nextLevelDPSDiff)); } else { $("#Hero"+hero.heroID+"nextLevelDPSDiff").html("+ "+Math.floor(hero.nextLevelDPSDiff)); }
	$("#Hero"+(hero.heroID)+"nextUpgradeCost").html(numberFormat(hero.nextUpgradeCost));
	//$("#Hero"+hero.heroID+"name").prop("title", hero.efficiency)
	for (var x = 0; x < 7; x++)
	{
		//$("#Hero"+hero.heroID+"skill"+(x+1)).prop("checked", hero.skills[x].isActive);
		$("#Hero"+(hero.heroID)+"skill"+(x+1)).prop("title", 
															hero.skills[x].name + "\n" + 
															hero.skills[x].bonusType + "\n" + 
															hero.skills[x].magnitude + "\n" +
															hero.skills[x].nextUpgradeCost
															// + hero.skills[x].efficiency
															);
	}
	//$("#Hero"+(hero.heroID)+"currentDPS").prop("title", "Additional dmg: " + (StatBonusAllDamage + hero.currentPassiveThisHeroDamage)*100 + "%");
}

function printArtifactInfo(artifact)
{
	if (artifact.level >= parseInt(artifact.maxLevel) && parseInt(artifact.maxLevel) > 0)
	{
		$("#"+(artifact.artifactID)+"upgradeCost").html("MAX LEVEL");
		$("#"+(artifact.artifactID)+"upgradeCost").prop("title", getArtifactRelicsSpent(artifact));
		$("#"+(artifact.artifactID)+"DamageBonus").html(Math.round(artifact.currentDamageBonus*10000)/100+"%");
		$("#"+(artifact.artifactID)+"artifactBonus").html(Math.round(artifact.currentBonus*10000)/100+"%"); 
	}
	else
	{
		$("#"+(artifact.artifactID)+"upgradeCost").html(artifact.upgradeCost);
		$("#"+(artifact.artifactID)+"upgradeCost").prop("title", getArtifactRelicsSpent(artifact));
		$("#"+(artifact.artifactID)+"DamageBonus").html(Math.round(artifact.currentDamageBonus*10000)/100+"%" + " (+" + Math.round(artifact.nextLevelDamageBonusDiff*10000)/100 + "%)");
		if (artifact.bonusPerLevel > 0)
		{ 
			$("#"+(artifact.artifactID)+"artifactBonus").html(Math.round(artifact.currentBonus*10000)/100+"%" + " (+" + Math.round(artifact.bonusPerLevel*10000)/100 + "%)"); 
		}
		else
		{ 
			$("#"+(artifact.artifactID)+"artifactBonus").html(Math.round(artifact.currentBonus*10000)/100+"%" + " (" + Math.round(artifact.bonusPerLevel*10000)/100 + "%)"); 
		}
	}
}

function UpdateArtifactsStats()
{
	for (var i = 0; i < ArtifactInfo.length; i++)
	{
		ArtifactInfo[i].currentBonus = totalArtifactBonus(ArtifactInfo[i].bonusPerLevel, ArtifactInfo[i].level);
		ArtifactInfo[i].nextLevelBonusDiff = totalArtifactBonus(ArtifactInfo[i].bonusPerLevel, ArtifactInfo[i].level);
		ArtifactInfo[i].upgradeCost = getArtifactUpgradeCost(ArtifactInfo[i]);
	}
	artifactBonusDamage = 0.0; 
	for (var x = 0; x < ArtifactInfo.length; x++)
	{
		ArtifactInfo[x].currentDamageBonus = totalDamageArtifactBonus(ArtifactInfo[x], ArtifactInfo[x].level);
		//alert(ArtifactInfo[x].currentDamageBonus + " - " + ArtifactInfo[x].artifactID + " - " + ArtifactInfo[x].level);
		ArtifactInfo[x].nextLevelDamageBonusDiff = totalDamageArtifactBonus(ArtifactInfo[x], ArtifactInfo[x].level + 1) - ArtifactInfo[x].currentDamageBonus;
		artifactBonusDamage += ArtifactInfo[x].currentDamageBonus;
	}
	//$("#artifactbonus").val(artifactBonusDamage*100);
}

function totalArtifactBonus(bonusPerLevel, level)
{
	return bonusPerLevel * level;
}

function getArtifactUpgradeCost(artifact)
{	
	if (artifact.level == 0) { return NextArtifactCost(); }
	var num1 = artifact.CostCoEff * Math.pow(artifact.level + 1, artifact.CostExpo);
	var num2 = Math.round(num1);
	return num2;
}

function getArtifactRelicsSpent(artifact)
{
	var num = 0.0;
	for (var x = 1; x < artifact.level; x++)
	{
		var num1 = artifact.CostCoEff * Math.pow(x + 1, artifact.CostExpo);
		var num2 = Math.round(num1);
		num += num2;
	}
	return num;
}

function NextArtifactCost()
{
	var num = 1;
	for (var i = 0; i < ArtifactInfo.length; i++)
	{
		if (ArtifactInfo[i].level > 0) { num += 1; }
	}
	return Math.floor((num * Math.pow(1.35, num)));
}
 
function totalDamageArtifactBonus(artifact, level)
{
	if (level > 0)
	{
		return (artifact.DamageBonus * (1.0 + (0.5 * (level - 1)))) * (1 + ArtifactInfo[25].currentBonus);
	}
	return 0;
}

function GetDPSByLevel(hero, level)
{
    var num3 = 0.0;
    if (IsEvolved(level))
    {
      num3 = Math.pow(levelIneffiency, (level - heroEvolveLevel)) * Math.pow((1.0 - (heroInefficiency * heroInefficiencySlowDown)), (hero.heroID + 30));
    }
    else
    {
      num3 = Math.pow(levelIneffiency, (level - 1)) * Math.pow((1.0 - (heroInefficiency * Math.min(hero.heroID, heroInefficiencySlowDown))), hero.heroID);
    }
    var num4 = 0.0;
    if (IsEvolved(level))
    {
      num4 = (((GetUpgradeCostByLevel(level - 1, hero.cost) * (Math.pow(heroUpgradeBase, (level - (heroEvolveLevel - 1))) - 1.0)) / ((heroUpgradeBase - 1.0))) * num3) * dMGScaleDown;
    }
    else
    {
      num4 = (((GetUpgradeCostByLevel(level - 1, hero.cost) * (Math.pow(heroUpgradeBase, level) - 1.0)) / ((heroUpgradeBase - 1.0))) * num3) * dMGScaleDown;
    }
    return (num4 * (1.0 + currentPassiveThisHeroDamage(hero) + StatBonusAllDamage)) * (1.0 + artifactBonusDamage);
}

function IsEvolved(iLevel)
{
	return (iLevel >= heroEvolveLevel);
}

function GetUpgradeCostByLevel(iLevel, purchaseCost)
{
    var num = 0.0;
    num = GetHeroBaseCost(iLevel, purchaseCost, iLevel) * Math.pow(heroUpgradeBase, iLevel);
    var a = num * (1.0 + ArtifactInfo[23].currentBonus);
    return Math.ceil(a);
}

function UpdatePlayerStats()
{
	HeroInfo[heroList[30]].currentDamage = GetAttackDamageByLevel(HeroInfo[heroList[30]].heroLevel);
	HeroInfo[heroList[30]].nextLevelDMGDiff = GetAttackDamageByLevel(HeroInfo[heroList[30]].heroLevel + 1) - HeroInfo[heroList[30]].currentDamage;
	HeroInfo[heroList[30]].nextUpgradeCost = GetPlayerUpgradeCostByLevel(HeroInfo[heroList[30]].heroLevel);
	HeroInfo[heroList[30]].MinCritDamage = HeroInfo[heroList[30]].currentDamage * CritDamagePassive * 0.3;
	HeroInfo[heroList[30]].MaxCritDamage = HeroInfo[heroList[30]].currentDamage * CritDamagePassive;
	HeroInfo[heroList[30]].AvgCritDamage = HeroInfo[heroList[30]].currentDamage * CritDamagePassive * 0.65;
	HeroInfo[heroList[30]].CritDamage = ((CritChance*100*HeroInfo[heroList[30]].AvgCritDamage) + ((1-CritChance)*100*HeroInfo[heroList[30]].currentDamage))/100;
	HeroInfo[heroList[30]].trueDamage = getPlayerTrueDamage(HeroInfo[heroList[30]].clicks, HeroInfo[heroList[30]].heroLevel);
	HeroInfo[heroList[30]].nextLeveltrueDamageDiff = getPlayerTrueDamage(HeroInfo[heroList[30]].clicks, HeroInfo[heroList[30]].heroLevel + 1) - HeroInfo[heroList[30]].trueDamage;
}

function getPlayerTrueDamage(clicks, iLevel)
{
	var num1 = GetAttackDamageByLevel(iLevel);
	var num2 = num1 * CritDamagePassive * 0.65;
	var num3 = ((CritChance*100*num2) + ((1-CritChance)*100*num1))/100;
	var num4 = num3 * clicks;
	return num4;
}

function GetAttackDamageByLevel(iLevel)
{
    var num = iLevel * Math.pow(1.05, iLevel);
    var num3 = TapDamagePassive;
    var num4 = TapDamageFromDPS * currentAllHeroDPS;
    //var num5 = PlayerModel.instance.GetStatBonus(BonusType.TapDamageActive);
	var num5 = 0;
    var num7 = ArtifactInfo[28].currentBonus;
    //var num8 = (((((num * (1.0 + statBonus)) + num4) * (1.0 + num3)) * (1.0 + num5)) * (1.0 + artifactDamageBonus)) * (1.0 + num7);
	var num8 = (((((num * (1.0 + StatBonusAllDamage)) + num4) * (1.0 + num3)) * (1.0 + num5)) * (1.0 + artifactBonusDamage)) * (1.0 + num7);
	//alert(num8);
    if (num8 <= 1.0)
    {
        num8 = 1.0;
    }
    return num8;
}

function GetPlayerUpgradeCostByLevel(iLevel)
{
    var num = Math.min(25, 3 + iLevel) * Math.pow(1.074, iLevel);
    var a = num * (1.0 + ArtifactInfo[23].currentBonus);
    return Math.ceil(a);
}

function UpdateAllHeroesStats()
{
	currentAllHeroDPS = 0.0;
	for (var i = 0; i < 30; i++)
	{
		var hero = HeroInfo[heroList[i]];
		hero.currentPassiveThisHeroDamage = currentPassiveThisHeroDamage(hero);
		hero.currentDPS = GetDPSByLevel(hero, hero.heroLevel);
		hero.nextLevelDPSDiff = GetDPSByLevel(hero, hero.heroLevel + 1) - hero.currentDPS;
		hero.nextUpgradeCost = GetUpgradeCostByLevel(hero.heroLevel, hero.cost);
		if (hero.heroID >= 2) 
		{	
			hero.isActive = false;
			if (HeroInfo[heroList[hero.heroID-2]].heroLevel > 0){ hero.isActive = true; }
		} 
		else if (hero.heroID <= 1)
		{ 	
			hero.isActive = true; 
		}	
		currentAllHeroDPS += HeroInfo[heroList[i]].currentDPS;
		//hero.nextSkill = hero.skills[0];
		//$("#Hero1skill1").prop("checked", HeroInfo[heroList[0]].skills[0].isActive);
	}
	//if (currentAllHeroDPS == 0) { currentAllHeroDPS = 1e-100; }
	UpdatePlayerStats();
	currentAllHeroDPS += getPlayerTrueDamage(HeroInfo[heroList[30]].clicks, HeroInfo[heroList[30]].heroLevel);
	if (currentAllHeroDPS == 0) { currentAllHeroDPS = 1e-100; }
	var player = HeroInfo[heroList[30]];
		player.currentSalary = currentAllHeroDPS  * (1 + StatBonusGoldAll);
		player.nextLevelSalaryDiff = (currentAllHeroDPS + player.nextLeveltrueDamageDiff) * (1 + StatBonusGoldAll);
		player.efficiency = player.nextUpgradeCost/(player.nextLevelSalaryDiff - player.currentSalary);
	for (var i = 0; i < 30; i++)
	{	
		var hero = HeroInfo[heroList[i]];
		hero.currentSalary = currentAllHeroDPS  * (1 + StatBonusGoldAll);
		hero.nextLevelSalaryDiff = (currentAllHeroDPS + hero.nextLevelDPSDiff) * (1 + StatBonusGoldAll);
		hero.efficiency = hero.nextUpgradeCost/(hero.nextLevelSalaryDiff - hero.currentSalary);
		for (var x = 0; x < hero.skills.length; x++)
		{	
			var skill = hero.skills[x];
			updateSkill("AllDamage", skill, hero);
			updateSkill("GoldAll", skill, hero);
			updateSkill("ThisHeroDamage", skill, hero);
			updateSkill("CritDamagePassive", skill, hero);
			updateSkill("TapDamageFromDPS", skill, hero);
			updateSkill("CritChance", skill, hero);
			updateSkill("TapDamagePassive", skill, hero);
			updateSkill("GoldTreasurePassive", skill, hero);
		}	
	}
}

function updateSkill(bonusType, skill, hero)
{
if (!(skill.isActive) && skill.bonusType == bonusType)
	{
		skill.isActive = true;
		GetStatBonusAllDamage();
		GetStatBonusAllGold();
		GetStatBonusCritDamagePassive();
		GetStatBonusTapDamageFromDPS();
		GetStatBonusCritChance();
		GetStatBonusTapDamagePassive();
		skill.dps = getPlayerTrueDamage(HeroInfo[heroList[30]].clicks, HeroInfo[heroList[30]].heroLevel);;
		for (var y = 0; y < 30; y++)
		{
			var hero2 = HeroInfo[heroList[y]];
			if (!(hero2.name == HeroInfo[skill.owner].name))
			{
				skill.dps+=GetDPSByLevel(hero2, hero2.heroLevel);
			}
			else
			{
				if (skill.reqLevel >= hero2.heroLevel)
				{
					skill.dps+=GetDPSByLevel(hero2, skill.reqLevel);
				}
				else
				{
					skill.dps+=GetDPSByLevel(hero2, hero2.heroLevel);
				}
			}
		}
		skill.isActive = false;
		GetStatBonusAllDamage();
		GetStatBonusAllGold();
		GetStatBonusCritDamagePassive();
		GetStatBonusTapDamageFromDPS();
		GetStatBonusCritChance();
		GetStatBonusTapDamagePassive();
		skill.currentSalary = currentAllHeroDPS  * (1 + StatBonusGoldAll);
		skill.nextLevelSalaryDiff = skill.dps * (1 + StatBonusGoldAll);
		//skill.nextUpgradeCost = GetUpgradeCostByMultiLevel(hero.heroLevel, skill.reqLevel, hero.cost) + (GetUpgradeCostByLevel(skill.reqLevel, hero.cost)*5);
		skill.nextUpgradeCost = GetSkillCost(skill, hero);
		skill.efficiency = skill.nextUpgradeCost/(skill.nextLevelSalaryDiff - skill.currentSalary);
		if(hero.heroLevel == skill.reqLevel) { skill.efficiency = 0; }
	}
}

function GetSkillCost(skill, hero)
{
	//alert(GetUpgradeCostByLevel(hero.skills[x].reqLevel, hero.cost)*5);
	var num = GetUpgradeCostByMultiLevel(hero.heroLevel, skill.reqLevel, hero.cost);
	var num2 = 0.0;
	for (var x = 0; x < 7; x++)
	{
		if (!(hero.skills[x].isActive))
		{
			num2 += GetUpgradeCostByLevel(hero.skills[x].reqLevel, hero.cost)*5;
		}
		if (hero.skills[x].name == skill.name) { break; }
	}
	return num + num2;
}

function Save()
{	
	//SetSkillsForTable();
	//GetLevels();
	UpdateTables();
	var text = [];
	for (var x = 0; x < 30; x++)
	{	
		var temp = [];
		for (var y = 0; y < 7; y++)
		{
			temp.push(HeroInfo[heroList[x]].skills[y].isActive);
		}
		text.push({level: HeroInfo[heroList[x]].heroLevel, skills: temp})
	}
	text.push({level: HeroInfo[heroList[30]].heroLevel, clicks: HeroInfo[heroList[30]].clicks})
	for (var y = 0; y < ArtifactInfo.length; y++)
	{	
		text.push({level: ArtifactInfo[y].level})
	}
	var save = JSON.stringify(text);
	$("#savedata").val(save);
	text = [];
	temp = [];
}

function Load()
{	
	var txt = $("#savedata").val();
	var txt2 = jQuery.parseJSON(txt);
	for (var x = 0; x < 30; x++)
	{	
		for (var y = 0; y < 7; y++)
		{
			HeroInfo[heroList[x]].skills[y].isActive = txt2[x].skills[y];
			HeroInfo[heroList[x]].heroLevel = txt2[x].level;
			$("#Hero"+(x+1)+"skill"+(y+1)).prop("checked", HeroInfo[heroList[x]].skills[y].isActive);
			$("#Hero"+(x+1)+"heroLevel").val(HeroInfo[heroList[x]].heroLevel);
		}
	}
	HeroInfo[heroList[30]].clicks = txt2[30].clicks;
	HeroInfo[heroList[30]].heroLevel = txt2[30].level;
	$("#player0clicks").val(HeroInfo[heroList[30]].clicks);
	$("#player0heroLevel").val(HeroInfo[heroList[30]].heroLevel);
	for (var y = 0; y < ArtifactInfo.length; y++)
	{	
		ArtifactInfo[y].level = txt2[(y+31)].level; 
		$("#Artifact"+(y+1)+"level").val(ArtifactInfo[y].level);
	}
	UpdateTables();
}

buildArtifacts();
BuildSkillBase();
UpdateTables();
function UpdateTables() {
	GetLevels();
	SetSkillsForTable();
	UpdateArtifactsStats();
	GetStatBonusAllDamage();
	GetStatBonusAllGold();
	GetStatBonusCritDamagePassive();
	GetStatBonusTapDamageFromDPS();
	GetStatBonusCritChance();
	GetStatBonusTapDamagePassive();
	UpdateAllHeroesStats();
	printAll();
}

function EfficiencyCalculations()
{	
	$("#output").html("");
	UpdateTables();
	GetEfficiency();
}

//1.1 - 1
//1.2 - x
//x = 1.2/1.1
//});
</script></body></html>